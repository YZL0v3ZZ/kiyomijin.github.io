{
    "version": "https://jsonfeed.org/version/1",
    "title": "My Violet Eva Garden • All posts by \"ctf小训\" category",
    "description": "",
    "home_page_url": "https://kiyomijin.github.io",
    "items": [
        {
            "id": "https://kiyomijin.github.io/2022/09/17/CTF%E5%B0%8F%E8%AE%AD/Misc/Misc%E2%80%94%E2%80%94%E7%A7%81%E6%9C%89bit%E9%9A%90%E5%86%99/",
            "url": "https://kiyomijin.github.io/2022/09/17/CTF%E5%B0%8F%E8%AE%AD/Misc/Misc%E2%80%94%E2%80%94%E7%A7%81%E6%9C%89bit%E9%9A%90%E5%86%99/",
            "title": "Misc——私有bit隐写",
            "date_published": "2022-09-17T06:02:32.000Z",
            "content_html": "<h2 id=\"0x01-知识点\"><a class=\"markdownIt-Anchor\" href=\"#0x01-知识点\">#</a> <strong>0x01 知识点</strong></h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">typedef FrameHeader</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;// 类型     字段名:bit数</span><br><span class=\"line\">unsigned int sync:12;                        //同步信息</span><br><span class=\"line\">unsigned int version:2;                      //版本</span><br><span class=\"line\">unsigned int layer: 2;                       //层</span><br><span class=\"line\">unsigned int error protection:1;             //CRC校验</span><br><span class=\"line\">unsigned int bitrate_index:4;                //位率</span><br><span class=\"line\">unsigned int sampling_frequency:2;           //采样频率</span><br><span class=\"line\">unsigned int padding:1;                      //帧长调节</span><br><span class=\"line\">unsigned int private:1;                      //保留字 【通常藏有flag】</span><br><span class=\"line\">unsigned int mode:2;                         //声道模式</span><br><span class=\"line\">unsigned int mode extension:2;        \t\t //扩充模式</span><br><span class=\"line\">unsigned int copyright:1;                    //版权   【通常藏有flag】</span><br><span class=\"line\">unsigned int original:1;                     //原版标志</span><br><span class=\"line\">unsigned int emphasis:2;                     //强调模式</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>帧长度是压缩时每一帧的长度， <code>包括帧头</code> 的 4 个字节（32bit）。它将填充的空位也计算在内。</li>\n<li>padding 的值会影响每一帧的长度（具体分析见下面的题目），因为只有 1 位，因此长度也只限于在 0 和 1 之间变化</li>\n</ul>\n<h2 id=\"0x02-题目分析\"><a class=\"markdownIt-Anchor\" href=\"#0x02-题目分析\">#</a> 0x02 题目分析</h2>\n<p>将解压后的 <code>1.mp3</code>  文件用 010Editor 打开</p>\n<p>可以看到一个 mp3 文件，里面基本上由 mf 数组构成。</p>\n<p><img src=\"image-20220917115510767.png\" alt=\"image-20220917115510767\"></p>\n<p>分析详见图片</p>\n<p><img src=\"image-20220917120013835.png\" alt=\"image-20220917120013835\"></p>\n<p>接着，可以发现，每个 mf 数组大小不一，有的是 0x1A1，有的 0x1A2</p>\n<p><img src=\"image-20220917120301874.png\" alt=\"image-20220917120301874\"></p>\n<blockquote>\n<p>图中可知，private_bit 的数值的在 0 和 1 中变化，可以让 <code>copyright</code>  、 <code>private_bit</code>  这样的单 bit 位在 0 和 1 之间发生改变，进而影响了单独 mf 数组的大小。因此，这两位在整个 mf 数组中连续拼接可能藏有 flag 或者重要的信息，优先提取。</p>\n</blockquote>\n<h2 id=\"0x03-解析脚本\"><a class=\"markdownIt-Anchor\" href=\"#0x03-解析脚本\">#</a> 0x03 解析脚本</h2>\n<p>脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">   <span class=\"comment\"># coding:utf-8</span></span><br><span class=\"line\">   <span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">   n = <span class=\"number\">0x399D0</span> + <span class=\"number\">2</span>  <span class=\"comment\"># 起始位置，为什么+2 下面有解释</span></span><br><span class=\"line\">   target_bit = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">   flag = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">   file = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;1.mp3&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"comment\"># 以二进制打开文件</span></span><br><span class=\"line\">   <span class=\"comment\"># 提取</span></span><br><span class=\"line\">   <span class=\"keyword\">while</span> n &lt; <span class=\"number\">0x294C6A</span>:  <span class=\"comment\"># 结束位置</span></span><br><span class=\"line\">       file.seek(n, <span class=\"number\">0</span>) <span class=\"comment\"># 从头吃掉第一帧前面的字节(0x399D0) + frame_sync、 mpeg_id、layer_id、protection_bit这四个字段(16bit，即2字节)</span></span><br><span class=\"line\">       byte = file.read(<span class=\"number\">1</span>)  <span class=\"comment\">#往后读取一个字节（8位）</span></span><br><span class=\"line\">       padding = <span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">ord</span>(byte))[-<span class=\"number\">2</span>] <span class=\"comment\">#从中提取倒数第2个bit 也就是padding的值 ord函数，是chr函数的对应，将字符变成10进制数字</span></span><br><span class=\"line\">       target_bit += <span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">ord</span>(byte))[-<span class=\"number\">1</span>] <span class=\"comment\">#从中提取倒数第1个bit 也就是private_bit的值，需要累加拼接</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> padding == <span class=\"string\">&quot;1&quot;</span>:</span><br><span class=\"line\">           n += <span class=\"number\">0x1A2</span></span><br><span class=\"line\">       <span class=\"keyword\">else</span>:</span><br><span class=\"line\">           n += <span class=\"number\">0x1A1</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"built_in\">print</span>(target_bit)</span><br><span class=\"line\"> </span><br><span class=\"line\">   <span class=\"comment\">#textArr = re.findall(&#x27;.&#123;&#x27;+str(8)+&#x27;&#125;&#x27;, result)</span></span><br><span class=\"line\">   textArr = re.findall(<span class=\"string\">r&#x27;\\d&#123;8&#125;&#x27;</span>, target_bit) <span class=\"comment\">#利用正则匹配每8个数字为一组，将其变为字符串数组方便处理</span></span><br><span class=\"line\">   <span class=\"built_in\">print</span>(textArr)</span><br><span class=\"line\">   <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> textArr:</span><br><span class=\"line\">       flag += <span class=\"built_in\">chr</span>(<span class=\"built_in\">int</span>(i, <span class=\"number\">2</span>)).strip(<span class=\"string\">&#x27;\\n&#x27;</span>)     <span class=\"comment\">#int(&#x27;二进制数&#x27;, 2) 就转成了10进制   chr(&#x27;10进制数&#x27;) 就转成字符</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"comment\">#print(flag) #发现后面有很多未知空字符，删也删不掉</span></span><br><span class=\"line\">   flag = re.findall(<span class=\"string\">r&#x27;\\w+\\&#123;.+\\&#125;&#x27;</span>,flag) <span class=\"comment\">#用正则匹配标准flag</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(flag[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<p 0k4_YOu_Seem_s0_cl3ver_t0_find_f1ag!=\"\">flag</p>\n<p><img src=\"image-20220917134916608.png\" alt=\"image-20220917134916608\"></p>\n<h2 id=\"0x04-常用正则补充\"><a class=\"markdownIt-Anchor\" href=\"#0x04-常用正则补充\">#</a> 0x04 常用正则 (补充)</h2>\n<p>①<strong>显示不可打印的字符</strong></p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\a</td>\n<td>报警</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td>换页</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>字表符</td>\n</tr>\n</tbody>\n</table>\n<p>②<strong>指定预定义的字符集</strong></p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\d</td>\n<td>任意一个十进制数字 [0-9]</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>任意一个非十进制数字</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>任意一个空白字符 (空格、换行符、换页符、回车符、字表符)</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>任意一个非空白字符</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>任意一个单词字符</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>任意个非单词字符</td>\n</tr>\n</tbody>\n</table>\n<p>③<strong>限定符 (？*+{n，m}.)</strong><br>\n 限定符主要是用来限定每个字符串出现的次数。</p>\n<table>\n<thead>\n<tr>\n<th>限定字符</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>？</td>\n<td>零次或一次</td>\n</tr>\n<tr>\n<td>*</td>\n<td>零次或多次</td>\n</tr>\n<tr>\n<td>+</td>\n<td>一次或多次</td>\n</tr>\n<tr>\n<td n=\"\"></td>\n<td>n 次</td>\n</tr>\n<tr>\n<td n,=\"\"></td>\n<td>至少 n 次</td>\n</tr>\n<tr>\n<td n,m=\"\"></td>\n<td>n 到 m 次</td>\n</tr>\n<tr>\n<td>.</td>\n<td>匹配任意一个字符（不包含换行符）</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"0x05-再来一道\"><a class=\"markdownIt-Anchor\" href=\"#0x05-再来一道\">#</a> 0x05 再来一道</h2>\n<p>翻看了几帧发现 <code>private_bit</code>  位都是 0，似乎并没有存储数据。但是在翻看的时候发现，<ins> <code>uint32 copyright</code>  这一位似乎内藏玄机</ins>，这一位在相邻几帧的数据有 0 有 1，查询得知这是版权位，通常不会出现不同帧有 0 有 1 的情况。</p>\n<p>于是决定将 <code>copyright</code>  位的数据提取出来看看。</p>\n<p><img src=\"image-20220917134512128.png\" alt=\"image-20220917134512128\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># coding:utf-8</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">0xF05A4</span> + <span class=\"number\">2</span>  <span class=\"comment\"># 起始位置，为什么+2 下面有解释</span></span><br><span class=\"line\">target_bit = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">flag = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">file = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;2.mp3&#x27;</span>, <span class=\"string\">&#x27;rb&#x27;</span>)  <span class=\"comment\"># 以二进制打开文件</span></span><br><span class=\"line\"><span class=\"comment\"># 提取</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> n &lt; <span class=\"number\">0xC12623</span>:  <span class=\"comment\"># 结束位置</span></span><br><span class=\"line\">    file.seek(n, <span class=\"number\">0</span>)  <span class=\"comment\"># 从头吃掉第一帧前面的字节(0x399D0) + frame_sync、 mpeg_id、layer_id、protection_bit这四个字段(16bit，即2字节)</span></span><br><span class=\"line\">    byte = file.read(<span class=\"number\">1</span>)  <span class=\"comment\"># 往后读取一个字节（8位）</span></span><br><span class=\"line\">    padding = <span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">ord</span>(byte))[-<span class=\"number\">2</span>]  <span class=\"comment\"># 从中提取倒数第2个bit 也就是padding的值</span></span><br><span class=\"line\">    file.seek(n + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    byte = file.read(<span class=\"number\">1</span>)</span><br><span class=\"line\">    target_bit += <span class=\"string\">&#x27;&#123;:08b&#125;&#x27;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">ord</span>(byte))[-<span class=\"number\">4</span>]  <span class=\"comment\"># 从中提取倒数第1个bit 也就是copyright的值，需要累加拼接</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> padding == <span class=\"string\">&quot;1&quot;</span>:</span><br><span class=\"line\">        n += <span class=\"number\">0x415</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        n += <span class=\"number\">0x414</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(target_bit)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># textArr = re.findall(&#x27;.&#123;&#x27;+str(8)+&#x27;&#125;&#x27;, result)</span></span><br><span class=\"line\">textArr = re.findall(<span class=\"string\">r&#x27;\\d&#123;8&#125;&#x27;</span>, target_bit)  <span class=\"comment\"># 利用正则匹配每8个数字为一组，将其变为字符串数组方便处理</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(textArr)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> textArr:</span><br><span class=\"line\">    flag += <span class=\"built_in\">chr</span>(<span class=\"built_in\">int</span>(i, <span class=\"number\">2</span>)).strip(<span class=\"string\">&#x27;\\n&#x27;</span>)  <span class=\"comment\"># int(&#x27;二进制数&#x27;, 2) 就转成了10进制   chr(&#x27;10进制数&#x27;) 就转成字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">flag = re.findall(<span class=\"string\">r&#x27;\\w+\\&#123;.+\\&#125;&#x27;</span>,flag)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(flag[<span class=\"number\">0</span>])</span><br></pre></td></tr></table></figure>\n<p b3d7bed5-e8da-4d9c-848c-e5d332d63bcd=\"\">flag</p>\n<p><img src=\"image-20220917134626086.png\" alt=\"image-20220917134626086\"></p>\n",
            "tags": [
                "CTF小训",
                "Misc"
            ]
        }
    ]
}